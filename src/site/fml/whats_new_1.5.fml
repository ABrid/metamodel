<?xml version="1.0" encoding="UTF-8"?>
<faqs xmlns="http://maven.apache.org/FML/1.0.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/FML/1.0.1 http://maven.apache.org/xsd/fml-1.0.1.xsd"
	title="What's new in MetaModel 1.5" toplink="false">
	
	<part id="features">
		<title>New features</title>
		
		<faq id="excel_xlsx">
			<question>Fluent query builder API</question>
			<answer>
				<p>MetaModel always did a lot to improve the type-safety and correctness of your
				queries. With version 1.5 we're pushing the query API even further by introducing
				a query builder that uses a fluent interface, eg. an interface that reads and feels
				like a regular query expression - except that it's type-safe and compile-time checked.</p>
				<p>The API ensures and aids you in building a query by exposing only the currently
				meaningful methods for your particular query. Here is a simple example:</p>
				<div class="source">
				DataContext dc = ...;<br/>
				Query q = dc.query().<b>from</b>(projects).<b>selectCount</b>().<b>and</b>(community).<b>where</b>(license).<b>equals</b>("oss").<b>groupBy</b>(community).toQuery();
				</div>
				<p>You can see more examples of the query builder API in the query-related examples in the menu.</p>
			</answer>
		</faq>
		
		<faq id="excel_xlsx">
			<question>Support for Excel 2007+ spreadsheets</question>
			<answer>
				<p>MetaModel 1.5 supports the new Excel 2007+ file format (<b>.xlsx</b> extension).
				As a user you can use the same factory method as with the older Excel spreadsheets.</p>
			</answer>
		</faq>
		
		<faq id="bom_detect">
			<question>Detection and usage of byte order mark (BOM) in UTF-* files</question>
			<answer>
				<p>When reading UTF-8 and UTF-16 text-files (primarily for CSV DataContexts)
				MetaModel 1.5 will scan the file for a
				<a href="http://en.wikipedia.org/wiki/Byte_order_mark" target="_blank">byte order mark</a> (BOM)
				and adjust the character encoding accordingly, if a BOM is found.</p>
			</answer>
		</faq>
		
		<faq id="approx_functions">
			<question>Approximated aggregate functions</question>
			<answer>
				<p>Sometimes it can be costly to do aggregate functions and maybe you're not always interested
				in the exact measure it generates, but just an approximated value. In MetaModel 1.5 you can set
				a special <i>FunctionApproximationAllowed</i> flag on a select item and MetaModel will use this
				to apply optimizations if this is possible.</p>
				<p>An example of a situation where it makes sense to use approximation is counting rows in very
				large (millions of rows) CSV files. Some times you're only interested in getting an rough idea of the
				amount of rows and this can be generated by sampling the file and counting lines. In such cases
				approximated aggregates introduce a huge performance improvement, but are of course only applicable
				where such an approximation is acceptable.</p>
			</answer>
		</faq>
		
		<faq id="excel_formulas">
			<question>Support for Excel formulas</question>
			<answer>
				<p>Excel formulas are automatically being evaluated in MetaModel 1.5. This means that your spreadsheet
				data can contain calculated values expressed as formulas. This feature is automatic and transparent to
				the user but will prevent the formula string from popping up as a data value.</p>
			</answer>
		</faq>
	</part>

	<part id="api">
		<title>Changes to the existing API</title>
		
		<faq id="immutable">
			<question>Immutable schema structures</question>
			<answer>
				<p>Previously the schema structure in MetaModel was mutable, meaning that you
				could change it even though it was being generated based on your datastore.</p>
				<p>This was actually an unwanted consequence of a too naive schema structure type
				system so we changed it in MetaModel 1.5. Basically it should not create problems
				for any users who have used the API as intended.</p>
				<p>Users wanting to manipulate schema structures (eg. for test purposes etc.) will
				find that there are now special subtypes for this purpose: MutableSchema, MutableTable,
				MutableColumn etc.</p>
			</answer>
		</faq>
		
		<faq id="org_package">
			<question>Root package rename</question>
			<answer>
				<p>As of version 1.5 the root package of MetaModel has changed from the old
				<i>dk.eobjects.metamodel</i> to <b>org.eobjects.metamodel</b>. We're painfully
				aware that this will break backwards compatibility because the new version is
				no longer a "drop in replacement" but on the other hand, to fix it is extremely
				simple: Simply do a text-based search and replace, replacing "dk.eobjects.metamodel"
				with "org.eobjects.metamodel".</p>
			</answer>
		</faq>
		
		<faq id="interfaces">
			<question>Everything as an interface</question>
			<answer>
				<p>All the main types in MetaModel (Schema, Table, Column, Relationship, DataSet,
				Row etc.) are now interfaces. This means it is significantly easier to write test-code
				that uses mock objects with MetaModel.</p>
			</answer>
		</faq>
		
		<faq id="slf4j">
			<question>Switch from commons-logging to slf4j</question>
			<answer>
				<p>Logging in Java have unfortunately been a complicated matter for a long time. One
				of the projects that have been gathering a lot of support is
				<a href="http://www.slf4j.org/" target="_blank">slf4j</a> which delivers a
				way to support multiple logging frameworks without all the (or at least less) hazzle
				of multiple configurations, jar files etc. Slf4j is a facade for just about any other
				logging framework, giving you both a simple way to get started and the choice to
				fine-tune if you need it.</p>
				<p>MetaModel 1.5 is now logging completely based on slf4j.</p>
			</answer>
		</faq>
		
		<faq id="dependencies">
			<question>Fewer external dependencies</question>
			<answer>
				<p>MetaModel 1.5 has way less dependencies than earlier versions. This change was made to
				make it easier to adopt MetaModel without a lot of concequences for you classpath in big
				projects.</p>
			</answer>
		</faq>
		
		<faq id="tweaks_and_enhancements">
			<question>Enhancements and optimization of native query translation</question>
			<answer>
				<p>For databases there have been quite a lot of minor tweaks which help optimize
				queries and metadata retrieval for various databases. For example:</p>
				<ul>
					<li>Escaping of strings in WHERE and HAVING clauses was significantly
					improved and works across different SQL dialects.</li>
					<li>In Microsoft SQL Server, we are now using the schema name "dbo" as the
					default schema if no better candidates are found.</li>
				</ul>
			</answer>
		</faq>
	</part>
	
	<part id="bugfixes">
		<title>Bugfixes</title>
		<faq id="csv_inputstream">
			<question>Handling of InputStream with CSV content</question>
			<answer>A bug was fixed related to temporary storage of an InputStream CSV content.</answer>
		</faq>
		<faq id="qualified_label_dot">
			<question>Qualified labels with dots in table names</question>
			<answer>Some schema structure elements, such as tables, can in rare circumstances
			contain dots in their names. The parser for qualified labels of tables and columns
			was not aware of this and thus interpreted any dots as delimitors, which caused it
			to not resolve qualified labels correctly.</answer>
		</faq>
		<faq id="qualified_label_null">
			<question>Qualified labels for schemas without a name</question>
			<answer>In some circumstances a schema will have no name. Therefore the qualified
			label for an item within that schema will not have a prepended schema name. The
			qualified label parser was not aware of this, and that has been fixed.</answer>
		</faq>
		<faq id="subquery_filter_item">
			<question>Inclusion of columns in subquery filter items</question>
			<answer>A bug was fixed in MetaModel's internal query engine, which was related
			to evaluation of columns that are only referenced in subquery filter items
			(WHERE or HAVING clause).</answer>
		</faq>
	</part>
</faqs>
